<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <title>Babylon Template</title>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }
            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>

        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

        <!-- <script src="https://unpkg.com/earcut@2.2.4/dist/earcut.min.js"></script> -->
        <script src="https://cdn.babylonjs.com/earcut.min.js"></script>

    </head>

   <body>
    <canvas id="renderCanvas"></canvas>
<script>
var canvas = document.getElementById('renderCanvas');
var engine = new BABYLON.Engine(canvas, true, {preserveDrawingBuffer: true, stencil: true});

function createScene() {
    console.clear();
    const scene = new BABYLON.Scene(engine);

    const camera = new BABYLON.ArcRotateCamera("Camera", -Math.PI / 2, Math.PI / 5, 20, BABYLON.Vector3.Zero());
    camera.attachControl(canvas, true);
	const light = new BABYLON.HemisphericLight("hemiLight", new BABYLON.Vector3(10, 10, 0));
    const light2 = new BABYLON.HemisphericLight("hemiLight2", new BABYLON.Vector3(10, -10, 0));
    light.intensity = 0.7;

    // const radius = 5; // Set the radius based on the approximate size of your shape

    // const shape = [];
    // for (let i = 0; i < 9; i++) {
    //     const angle = (2 * Math.PI * i) / 9; // Distribute vertices evenly around the circle
    //     const x = radius * Math.cos(angle);
    //     const z = radius * Math.sin(angle);
    //     shape.push(new BABYLON.Vector3(x, 0, z));
    // }
			  
    // const extrudedPolygon = BABYLON.MeshBuilder.ExtrudePolygon("polygon", {shape:shape, depth: 2 });


    const radius = 50;  // Radius of the path arc
    const arcDegrees = 56;  // Degrees of the arc
    const polygonRadius = 5;  // Radius of the polygon
    const polygons = createArcPolygons(radius, arcDegrees, polygonRadius, 9);
    const extrudedPolygonMesh = extrudePolygons(polygons);
   scene.meshes.push(extrudedPolygonMesh);
 //   const extrudedPolygon = BABYLON.MeshBuilder.ExtrudePolygon("polygon", {shape:polygons, depth: 2 });

    return scene;
}

var scene = createScene();

engine.runRenderLoop(function() {
    scene.render();
});
    
window.addEventListener('resize', function(){
    engine.resize();
})

function createPolygonVertices(numSides, radius) {
    const points = [];
    for (let i = 0; i < numSides; i++) {
        const angle = (2 * Math.PI * i) / numSides;
        const x = radius * Math.cos(angle);
        const z = radius * Math.sin(angle);
        points.push(new BABYLON.Vector3(x, 0, z));
    }
    return points;
}

function createArcPolygons(radius, arcDegrees, polygonRadius, numSides) {
    const numSteps = 10; // Number of steps or nonagons along the arc
    const arcRadians = BABYLON.Tools.ToRadians(arcDegrees);
    const polygons = [];

    for (let i = 0; i <= numSteps; i++) {
        const angle = arcRadians * (i / numSteps);
        const x = radius * Math.cos(angle);
        const z = radius * Math.sin(angle);
        const polygonVertices = createPolygonVertices(numSides, polygonRadius);

        // Translate and rotate polygon vertices
        polygonVertices.forEach(vertex => {
            vertex.rotateByQuaternionAroundPointToRef(
                BABYLON.Quaternion.FromEulerAngles(0, -angle, 0),
                BABYLON.Vector3.Zero(), vertex
            );
            vertex.addInPlace(new BABYLON.Vector3(x, 0, z));
        });

        polygons.push(polygonVertices);
    }
    return polygons;
}

function extrudePolygons(polygons) {
    const customMesh = new BABYLON.Mesh("polygonExtrusion", scene);
    const vertexData = new BABYLON.VertexData();
    const positions = [];
    const indices = [];

    polygons.forEach((polygon, nIdx) => {
        if (nIdx < polygons.length - 1) {
            polygon.forEach((vertex, vIdx) => {
                positions.push(vertex.x, vertex.y, vertex.z);
                let nextNonagonIdx = nIdx + 1;
                let nextVertexIdx = (vIdx + 1) % polygon.length;
                let baseIdx = nIdx * polygon.length + vIdx;
                let nextBaseIdx = nextNonagonIdx * polygon.length + vIdx;

                // Connect vertices to form two triangles for each face
                indices.push(baseIdx, nextBaseIdx, baseIdx + 1);
                indices.push(baseIdx + 1, nextBaseIdx, nextBaseIdx + 1);
            });
        }
    });

    vertexData.positions = positions;
    vertexData.indices = indices;
    vertexData.applyToMesh(customMesh, true);
    return customMesh;
}

function getEdgesData(mesh) {
    const positions = mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);
    const indices = mesh.getIndices();
    const nbFacets = indices.length / 3; // number of triangular facets the mesh is made up from
    const edgeFacetsData = []; // array to store the edge facet data, ie when not belonging to top or bottom face
    const facetsOnEdges = []; //array to store the edge facet
    const epsilon = Math.pow(10, -8);  
    for ( let i = 0; i < nbFacets; i++) {
        const p0Index = indices[3 * i];
        const p1Index = indices[3 * i + 1];
        const p2Index = indices[3 * i + 2];

        const p0 = new BABYLON.Vector3(positions[p0Index * 3], positions[p0Index * 3 + 1], positions[p0Index * 3 + 2]);
        const p1 = new BABYLON.Vector3(positions[p1Index * 3], positions[p1Index * 3 + 1], positions[p1Index * 3 + 2]);
        const p2 = new BABYLON.Vector3(positions[p2Index * 3], positions[p2Index * 3 + 1], positions[p2Index * 3 + 2]);
        const norm = BABYLON.Vector3.Cross(p1.subtract(p0), p2.subtract(p0));
        norm.normalize();
        if (norm.x <= 0) { //always make norm.x position for later comparison of norms
            norm.x *= -1;
            norm.y *= -1;
        }
        if (Math.abs(norm.y) < epsilon) { //floating point close to 0
            facetsOnEdges.push(i);
            edgeFacetsData.push([i, p0, p1, p2, norm]);
        }
    };
    //console.log(edgeFacetsData);
    const edges = []; //array to store all facets belonging to an edge
    const adjEdges = []; //array to store which edges are adjacent to each other
    const len = edgeFacetsData.length;
    for (let i = 0; i < len; i++) {
        const index = edgeFacetsData[i][0];
        const p = [];
        p[0] = edgeFacetsData[i][1];
        p[1] = edgeFacetsData[i][2];
        p[2] = edgeFacetsData[i][3];
        const norm = edgeFacetsData[i][4];
        const shared = new Set(); //set to store all triangular facets that are adjacent and share a normal
        const adjShared = new Set(); //set to store all triangular facets that are adjacent and do not share a normal
        for (j = i + 1; j < len; j++) {
            const otherIndex = edgeFacetsData[j][0];
            const pOther = [];
            pOther[0] = edgeFacetsData[j][1];
            pOther[1] = edgeFacetsData[j][2];
            pOther[2] = edgeFacetsData[j][3];
            const otherNorm = edgeFacetsData[j][4];
            for (let m = 0; m < 3; m++) {
                for (let n = 0; n < 3; n++) {
                    const adjoin0 = p[n].equalsWithEpsilon(pOther[m], epsilon) && p[(n + 1) % 3].equalsWithEpsilon(pOther[(m + 1) % 3], epsilon);
                    const adjoin1 = p[n].equalsWithEpsilon(pOther[(m + 1) % 3], epsilon) && p[(n + 1) % 3].equalsWithEpsilon(pOther[m], epsilon);
                    if (adjoin1 || adjoin1) {
                        if (norm.equalsWithEpsilon(otherNorm, epsilon)) { // belong to same edge
                            shared.add(index);
                            shared.add(otherIndex);
                        }
                        else { //belong to adjacent edges
                            adjShared.add(index);
                            adjShared.add(otherIndex);
                        }
                    }
                }
            }
        }
        if (shared.size > 0) {
            edges.push(shared);
        }
        if (adjShared.size > 0) {
            adjEdges.push(adjShared);
        }
    }

    /* Each entry in edges list the triangular facets
        * thatmake up that edge. However they may not yet
        * be in order around the shape, This depends on
        * how the shape was created.
    */
    
    //map each facet to the edge it belongs to
    fctToEdge = {};
    for (let i = 0; i < edges.length; i++) {
        edges[i].forEach(function(facet) {
            if (!(facet in fctToEdge)) {
                fctToEdge[facet] = new Set();
            }
            fctToEdge[facet].add(i);
        });
    }

    //change from set to value as easier to read value
    const facetToEdge = {};
    for (let el in fctToEdge) {
        facetToEdge[el] = Array.from(fctToEdge[el])[0];
    }

    //map edge to adjoining edge
    const egToEdge = {};
    for (let i = 0; i < adjEdges.length; i++) {
        const adjArray = Array.from(adjEdges[i]);
        for (let j = 0; j < adjArray.length; j++) {
            const facet0 = adjArray[j];
            const edge0 = facetToEdge[facet0];
            if (!(edge0 in egToEdge)) {
                egToEdge[edge0] = new Set();
            }
            for (let k = j + 1; k < adjArray.length; k++) {
                const facet1 = adjArray[k];
                const edge1 = facetToEdge[facet1];;
                if (!(edge1 in egToEdge)) {
                    egToEdge[edge1] = new Set();
                }
                if (edge0 !== edge1) {
                    egToEdge[edge0].add(edge1);
                    egToEdge[edge1].add(edge0);
                }
            }
        };
    }

    //change from set to Array as easier to to iterate
    const edgeToEdge = {};
    for (el in egToEdge) {
        edgeToEdge[el] = Array.from(egToEdge[el])
    }

    //change entries from set to array for easier iteration
    const edgesAsArrays = edges.map((el) => {
        return Array.from(el);
    })

    return({edges: edgesAsArrays, facetToEdge: facetToEdge, edgeToEdge:edgeToEdge})

}
</script>
</body>
</html>